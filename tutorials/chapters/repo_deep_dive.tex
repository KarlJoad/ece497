\chapter{Repository Deep Dive}\label{chap:Repository_Deep_Dive}
In this section, we lightly discuss each of the subdirectories present within the root of Chipyard, take note of any particularly important files, and demonstrate how this entire system is put together.

\section{Makefiles, or the Glue of this Framework}\label{sec:Makefiles_in_Chipyard}
Chipyard makes \textbf{heavy} use of Makefiles to pull together and automate various parts of the build system.
Variables and/or values that are more shared between different ways of building systems are higher in the directory structure.

Thus, some of the most overarching commands and variables for this project are defined in \file{chipyard/variables.mk}.
One of the first things defined within this file are numerous output messages.

\subsection{\texttt{SUB\_PROJECT}}\label{subsec:Makefile_SUB_PROJECT}
The first notable part of the \file{variables.mk} file is the \texttt{SUB\_PROJECT} defaulting variable.
This particular variable is what allows for easy re-configuration of the entire framework to support elaborating your own CPU designs.
By changing this file between one of the well-defined options, one can easily re-use major portions of Chipyard's architecture.

For example, to switch from a CPU deifned by Chipyard to one that is uses the Hwacha accelerator, one just needs to say \mintinline{bash}{make SUB_PROJCT=hwacha}, and all the necesssary configuration variables are changed.

\subsection{Building Each Subproject}\label{subsec:Building_Each_Subproject}
The next notable part of this file is its large \mintinline{make}{ifeq ... endif} blocks.
Each one of these defines a different subproject that can be built and elaborated upon by Chipyard and its surrounding framework.
These subproject defining blocks each define multiple higher-level variables which are the variables that are actually used to build and test each of the CPUs.
Each of the variables is important, and Chipyard provided documentation for each variable inside \file{variables.mk}.
However, additional information that we gathered through trial-and-error is presented below.

\subsection{About}\label{sec:About_Verilator_Simulator}
The primary way to simulate SoCs' designed using the Chipyard framework is via Verilator simulations.
The directory for verilator is \file{chipyard/sims/verilator}.
An example simulation can be run by using \mintinline{bash}{make} in the verilator directory.
Running the \texttt{make} command produces a simulator executable in the verilator directory.

Custom Chipyard configs can be simulated by running \mintinline{bash}{make CONFIG=<your custom config>}.
For example, if your project name was ``TestConfig'', running \mintinline{bash}{make CONFIG=TestConfig} would create an executable called \file{simulator-chipyard-TestConfig} in the \file{verilator} directory.
Custom RISCV code can be run by using the command \mintinline{bash}{./simulator-chipyard-TestConfig /path/to/riscv/executable} from the \file{chipyard/sims/verilator} directory.

\subsection{Generators}\label{sec:Generators}
\subsubsection{Chipyard Generator}\label{sec:Chipyard_Generator}
\subsubsection{SHA3 Accelerators}\label{sec:SHA3_Accelerators_Generator}

\subsection{Custom Configurations}\label{sec:Custom_Configurations}
Custom Configs can be created in the directory \mintinline{bash}{chipyard/generators/chipyard/src/main/scala/config/}.
For example, I created a new scala file called \file{NewTestConfig.scala} in the directory, allowing me to create a simulator from a class inside the NewTestConfig.scala file.
Example Configs can be found in  \file{RocketConfigs.scala} in the same directory.

% Include custom config example


\subsection{FPGA Implementation}\label{sec:FPGA_Implementation}


\subsubsection{About}\label{sec:About}

\begin{figure}[h!tbp]
  \centering
  \includegraphics[width=0.7\linewidth]{./NewTestConfig.png}
  \caption{\file{NewTestConfig.scala}}
  \label{fig:newtestconfig}
\end{figure}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../doc"
%%% End:
