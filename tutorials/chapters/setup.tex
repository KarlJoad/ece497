\chapter{Setup}\label{chap:Setup}
\section{Introduction}\label{sec:Introduction}
This document is intended to serve as a record of the work performed for the ECE 497 special project supervised by Professor Jia Wang during the Spring 2021 semester.
In this document, we will specify how our project repository was created, outline issues we ran into, and provide guidance on how to better setup the Chipyard Framework.

Chipyard is a framework for designing, elaborating, simulating, testing, and building RISC-V CPU designs.
It provides the functionality to define a set of standard CPU designs, but also allows for the end-user to describe their own custom designs and integrate them as first-class citizens in the framework.
It also provides a toolkit for verifying that elaborated CPU designs meet the RISC-V ISA standard, ensuring designed chips are compliant.
There are also tools for writing the elaborated designs out to \gls{fpga} bitstreams, so that simulation can be sped up and execution can occur on \gls{soft-core}s.
Lastly, Chipyard includes tools for a VLSI-design workflow, to implement the elaborated CPU design on actual silicon.

\section{Project Environment}\label{chap:Project_Environment}
The first step to using the Chipyard Framework is creating a project environment and obtaining all of the Chipyard dependencies.
In this document, we assume you are using Ubuntu 20.04 LTS, running in a virtual machine with \textbf{at least}:
\begin{itemize}
\item 4 cores
\item \SI{16}{\giga\byte} of RAM, or more
\item \SI{250}{\giga\byte} disk image
\end{itemize}

Much of the disk space that has been allocated will be utilized, as the entire RISC-V toolchain and Xilinx Vivado Suite require a large amount of disk space.

This document will work equally well in other distributions, so long as the versions of the dependencies are matched.
Chipyard also has explicit support for CentOS, which extends to Fedora and RHEL as well.
In addition, installing and using Linux natively works as well.

\section{Building Chipyard}\label{sec:Building_Chipyard}
Here, we present the necessary steps to retrieving all the dependencies required to set up Chipyard for local development and simulation use.
All of the code shown in the listings of this section is gathered in the \file{code} subdirectory.
We developed this documentation using version \href{https://github.com/ucb-bar/chipyard/releases/tag/1.4.0}{\textbf{1.4.0}}\footnote{Git Commit Hash: \href{https://github.com/ucb-bar/chipyard/commit/58076cfb260a3be502d6d1c25b577da39277a7fc}{58076cfb260a3be502d6d1c25b577da39277a7fc}} of Chipyard.

\subsection{Chipyard Dependencies}\label{sec:Chipyard_Dependencies}
To gather the Chipyard dependencies, follow the \href{https://chipyard.readthedocs.io/en/latest/}{Chipyard} documentation closely.
Specifically, the \href{https://chipyard.readthedocs.io/en/latest/Chipyard-Basics/Initial-Repo-Setup.html}{Section 1.4} of the documentation outlines how to prepare your operating system for development using the Chipyard framework.

A paraphrased reproduction of these steps are shown below.

\subsubsection{Retrieve/Install Dependencies}\label{sec:Retrive_Install_Dependencies}
Chipyard relies on numerous dependencies and libraries to read files and build the required Verilog files.
In addition, Chipyard relies on \texttt{sbt}, the Scala Build Tool, as a majority of Chipyard and its dependencies are written in Scala.

\Cref{lst:Ubuntu_Chipyard_Deps_Setup} is a script that handles fetching and installing all the dependencies for you.
Note that this does \textbf{not} work for installing the dependencies for Linux distributions that do not use the \texttt{apt} package manager.

\begin{listing}[h!tbp]
\bashsourcefile{./code/ubuntu-chipyard-deps-setup.sh}
\caption{Fetch Chipyard Dependencies using \texttt{apt} on Ubuntu}
\label{lst:Ubuntu_Chipyard_Deps_Setup}
\end{listing}

\subsubsection{Build Verilator from Source}\label{sec:Build_Verilator_from_Source}
Chipyard's documentation recommends building \href{https://www.veripool.org/wiki/verilator}{Verilator} (an open-source (System)Verilog simulator and compiler) from source.

A small script has been provided that handles this for you in \Cref{lst:Build_Verilator_from_Source}.
Note that this does \textbf{not} work for installing the dependencies required to build Verilator for Linux distributions that do not use the \texttt{apt} package manager.

\begin{listing}[h!tbp]
\bashsourcefile{./code/build-verilator.sh}
\caption{Building Verilator from Source}
\label{lst:Build_Verilator_from_Source}
\end{listing}

\subsubsection{Fetching Chipyard and its Direct Dependencies}\label{sec:Fetching_Chipyard_Direct_Dependencies}
In addition to the library and external programs that Chipyard depends on, it also uses git submodules to track direct dependencies.
Direct dependencies are projects that Chipyard directly relies on.
These include SiFive's CPU designs, the BOOM CPU design, rocket-chip, and several others.

\Cref{lst:Fetch_Chipyard_and_Submodules} has been provided that handles this for you.

\begin{listing}[h!tbp]
\bashsourcefile{./code/fetch-chipyard-and-submodules.sh}
\caption{Fetch Chipyard and Submodules}
\label{lst:Fetch_Chipyard_and_Submodules}
\end{listing}

\subsection{Building a Toolchain}\label{sec:Building_Toolchain}
To compile programs from C to RISC-V instructions, there are several tools you need, when grouped together is called a toolchain.
Your cloned Chipyard repository contains a script to install these.
You can run the script to build a good general-purpose toolchain using \bashinline{./scripts/build-toolchains.sh riscv-tools} while inside your local copy of the cloned Chipyard repository.

\subsubsection{Environment Variables}\label{sec:Environment_Variables}
Once the toolchain is built, an environment-setup script is emitted to the root of your local copy of Chipyard, with the name \file{env.sh}.
This file is a bash script that changes your \texttt{PATH}, \texttt{RISCV}, and \texttt{LD\_LIBRARY\_PATH} environment variables so that Chipyard can find everything it needs.

To alleviate any issues that may occur due to misconfigured or non-existent environment variables, there are two possible quality of life improvements you can make.
\begin{enumerate}
\item Add the line \bashinline{source /path/to/chipyard/env.sh} to your \texttt{.bashrc} file in your home directory.
  After adding this to your \texttt{.bashrc} file, restart your shell, or re-\texttt{source} your \file{.bashrc} and continue.
\item Install the \href{https://direnv.net/}{\texttt{direnv}} package and use it to automatically change your environment variables for you, instead of having them constantly loaded the way the previous option does.
\end{enumerate}

\section{Example CPU Design}\label{sec:Example_CPU_Design}
In this section, we show how to build and simulate the default CPU Chipyard defines.
This particular CPU is relatively easy to elaborate, requiring just \SI{6}{\giga\byte} of memory.

\subsection{Building the Example Design}\label{sec:Building_Example_Design}
To build the example design that Chipyard defines, all you must do is enter one of the simulator directories and type \bashinline{make}.
This \textbf{does} require that both the RISC-V toolchain you built and Verilator Verilog simulator be loaded into your environment~(see \Cref{sec:Environment_Variables}).
If one of these is not available, the \texttt{make} command will print out an error message describing what it is failing on.

\begin{blackbox}
  It is strongly recommended that you parallelize the elaboration of the CPU design.
  You can achieve this by passing the \texttt{-j [N]} flag to \texttt{make}.
  You may replace the \texttt{[N]} with a number to indicate the number of your CPU cores to use for building.

  \textbf{If you omit the \texttt{[N]} entirely, the build system will use ALL cores!}

  The elaboration of the default \texttt{RocketConfig} requires about \SI{6.5}{\giga\byte} of main memory.
  Otherwise the process will fail with \bashinline{make: *** [firrtl_temp] Error 137} which is most likely related to limited resources.
  Other configurations might require even more main memory~\cite{chipyard}.

  Using many cores increases the amount of system memory required, so be sure that you do not request too many cores be used if you are limited on memory.
\end{blackbox}

The commands to run, in order, are:
\begin{enumerate}
\item \bashinline{cd chipyard/sims/verilator}
\item \bashinline{make}
\end{enumerate}

\begin{blackbox}
  To parallelize the Verilator simulator, you must pass the \texttt{VERILATOR\_THREADS} variable to the \texttt{make} command.
  As an example, \bashinline{make VERILATOR_THREADS=4} will inform Verilator to use 4 cores/threads when simulating the design.
\end{blackbox}

Once the elaboration of the design is finished, an \textbf{executable} called \file{simulator-chipyard-RocketConfig} is produced.
This is an executable that is capable of running any RISC-V compatible code.

\subsection{Running the Example Design}\label{sec:Running_Example_Design}
To run arbitrary code, the executable takes the ELF file of the program to run as a parameter.
An example of the command to run is shown in \Cref{lst:Running_Example_Design}.

\begin{listing}[h!tbp]
\begin{bashsource}
./simulator-chipyard-RocketConfig $RISCV/riscv64-unknown-elf/share/riscv-tests/isa/rv64ui-p-simple
\end{bashsource}
\caption{Run Arbitrary RISC-V Programs using Example Design}
\label{lst:Running_Example_Design}
\end{listing}

Chipyard also provides a quality-of-life \texttt{make} directive when running these programs, shown in \Cref{lst:Running_Example_Design-Make}.

\begin{listing}[h!tbp]
\begin{bashsource}
make run-binary BINARY=<path/to/riscv/elf>
\end{bashsource}
\caption{\texttt{make} command to run arbitrary RISC-V programs using Example Design}
\label{lst:Running_Example_Design-Make}
\end{listing}

Using the \texttt{make} directive also allows the built design to accept many common command line options, including redirecting \texttt{STDOUT} to a file.

\subsection{Simulating the Example Design}\label{sec:Simulating_Example_Design}
Similar to \Cref{sec:Running_Example_Design}, the simulations are actually just a set of RISC-V programs designed to test the built designs.
There are two main commands for running the simulation test suite: \Cref{lst:ASM_Tests,lst:Run_Benchmark_Tests}.

\begin{listing}[h!tbp]
\begin{bashsource}
make run-asm-tests
\end{bashsource}
\caption{Run Compliance Tests to RISC-V ISA}
\label{lst:ASM_Tests}
\end{listing}


\section{Xilinx Vivado Suite Installation}\label{sec:Xilinx_Vivado_Suide_Install}
The \href{https://www.xilinx.com/support/download.html}{Xilinx Vivado Suite} is important to be installed if any work regarding an FPGA is to be conducted.
While performing this work and preparing this document, we used the ``offline installation'' version of the Xilinx Unified Installer (version 2020.2), so no \nth{3} party libraries would need to be installed.
Xilinx is supported for a variety of operating systems, including Ubuntu\footnote{Xilinx only officially offers support for Ubuntu 16.04.2 LTS, but it should work on any Ubuntu version since then.}
When conducting the installation, be sure to select the ``Vitis'' installation target instead of just selecting ``Vivado''.
Installing Vitis will install both Vivado, and all other Xilinx tools needed for implementing FPGA projects.

\section{Other Useful Projects}\label{sec:Other_Useful_Projects}
\subsection{Freedom E SDK}\label{sec:Freedom_E_SDK}
\href{https://github.com/sifive/freedom-e-sdk}{This repository} is maintained by SiFive, and provides several useful tools for designing, uploading, and debugging software to FPGA devices~\cite{freedomESDK}.
This repository is specifically meant for use with SiFive IP, but can still be utilized for Chipyard projects with some modification.

For setting up this repository with its dependencies and compiling the necessary programs, refer to their \href{https://github.com/sifive/freedom-e-sdk#setting-up-the-sdk}{Prerequisites section}.

\subsection{Freedom Tools}\label{sec:Freedom_Tools}
\href{https://github.com/sifive/freedom-tools}{This repository} is maintained by SiFive~\cite{freedomTools}.
It will be used to generate several tools that will be used during this project, such as:
\begin{itemize}
\item The GCC cross-compiler for RISC-V (and many extension sets of RISC-V)
\item OpenOCD, which assists users in debugging their FPGA designs
\item RISC-V QEMU for system testing through emulation
\item And other useful software.
\end{itemize}

These tools take a considerable amount of time and disk space to compile so it is best to run the \texttt{make} command as \mintinline{bash}{make -j`nproc`} to parallelize compiling.
Note that this will consume many system resources, and you should be prepared to have an unresponsive machine while the system is building these tools.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../doc"
%%% End:
